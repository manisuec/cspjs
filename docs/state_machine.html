<!DOCTYPE html>

<html>
<head>
  <title>State machine support for task.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="channel.html">
                channel.js
              </a>
            
              
              <a class="source" href="state_machine.html">
                state_machine.js
              </a>
            
              
              <a class="source" href="stream.html">
                stream.js
              </a>
            
              
              <a class="source" href="task.html">
                task.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="state-machine-support-for-task-js">State machine support for task.js</h1>
<p>This file contains miscellaneous state machine management code
that is used by the code generated by the <code>task</code> macro in task.js.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> Channel = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./channel'</span>);

<span class="hljs-keyword">var</span> nextTick = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.setImmediate || process.nextTick;
}());

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">State</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.id = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.args = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
    <span class="hljs-keyword">this</span>.err = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.unwinding = [];
    <span class="hljs-keyword">this</span>.waiting = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.isFinished = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.isUnwinding = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.currentErrorStep = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.abort_with_error = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">controlAPIMaker</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> state_machine = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create({}, {
        abort: {
            value: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
                <span class="hljs-keyword">if</span> (state_machine.state.waiting &gt; <span class="hljs-number">0</span>) {
                    state_machine.state.abort_with_error = err;
                } <span class="hljs-keyword">else</span> {
                    state_machine.callback(err);
                }
            }
        },
        isWaiting: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                <span class="hljs-keyword">return</span> state_machine.state.waiting &gt; <span class="hljs-number">0</span>;
            }
        },
        isFinished: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                <span class="hljs-keyword">return</span> state_machine.state.isFinished;
            }
        }
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StateMachine</span><span class="hljs-params">(context, callback, fn, task_fn)</span> {</span>

    <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">new</span> State();
    <span class="hljs-keyword">this</span>.fn = fn;
    <span class="hljs-keyword">this</span>.task_fn = task_fn;
    <span class="hljs-keyword">this</span>.context = context;
    <span class="hljs-keyword">this</span>.finalCallback = callback;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The following two will be initialized if the body
of the state machine contains a finally {} block.
If not, they can remain null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.captureStateVars = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Might be initialized to function () { return array; }</span>
    <span class="hljs-keyword">this</span>.restoreStateVars = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Might be initialized to function (array) { assign state variables; }</span>

    <span class="hljs-keyword">this</span>.boundStep = <span class="hljs-keyword">this</span>.step.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.boundUnwind = <span class="hljs-keyword">this</span>.unwind.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.controlAPIMaker = controlAPIMaker.bind(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Initialize the jump table structure if not done already.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.task_fn.cachedJumpTable = <span class="hljs-keyword">this</span>.task_fn.cachedJumpTable || {};

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

StateMachine.prototype.start = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.goTo(<span class="hljs-number">1</span>);
};

StateMachine.prototype.step = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.state.waiting--;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.abort_with_error) {
        <span class="hljs-keyword">this</span>.performAbort();
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.fn.apply(<span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.state.args);
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>If an abortion has been requested by the state machine
user, then bail out on the next step.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>StateMachine.prototype.performAbort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.state.abort_with_error;
    <span class="hljs-keyword">this</span>.state.abort_with_error = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.fn.call(<span class="hljs-keyword">this</span>.context, err);
};

StateMachine.prototype.goTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">this</span>.state.id = id;
    <span class="hljs-keyword">this</span>.state.strict_unwind = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.state.waiting++;
    nextTick(<span class="hljs-keyword">this</span>.boundStep);
};

StateMachine.prototype.thenTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.state.waiting++;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> _self = self;
        <span class="hljs-keyword">var</span> _state = _self.state;
        _state.waiting--;
        <span class="hljs-keyword">if</span> (!done) {
            done = <span class="hljs-literal">true</span>;
            _state.id = id;
            <span class="hljs-keyword">if</span> (_state.abort_with_error) {
                _self.performAbort();
            } <span class="hljs-keyword">else</span> {
                _self.fn.apply(_self.context, <span class="hljs-built_in">arguments</span>); 
            }
        } <span class="hljs-keyword">else</span> {
            console.error(<span class="hljs-string">'Callback called repeatedly!'</span>);
        }
    };
};

StateMachine.prototype.thenToWithErr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.state.waiting++;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, result)</span> {</span>
        <span class="hljs-keyword">var</span> _self = self;
        <span class="hljs-keyword">var</span> _state = _self.state;
        _state.waiting--;
        <span class="hljs-keyword">if</span> (!done) {
            done = <span class="hljs-literal">true</span>;
            _state.id = id;
            <span class="hljs-keyword">if</span> (_state.abort_with_error) {
                _self.performAbort();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt;= <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Slightly more efficient in the common case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                _self.fn.call(_self.context, <span class="hljs-literal">null</span>, err, result);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> argv = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);
                argv.unshift(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Push the err argument to the explicit range.</span>
                _self.fn.apply(_self.context, argv); 
            }
        } <span class="hljs-keyword">else</span> {
            console.error(<span class="hljs-string">'Callback called repeatedly!'</span>);
        }
    };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>StateMachine supports a single global error notification point.
You can set StateMachine.onerror to an error callback function that
will be called asynchronously with two arguments - the error and 
the state machine instance within which the error was raised.
You can use this, for example, to log all such errors.</p>
<p>If this callback is to process an error and err is an instance of
Error, then an additional ‘.cspjsStack’ property is added. This
property is an array to which more context will get added as the
error bubbles up. Each context is expressed in the form -
    task_fn_name:<id>
where “task_fn_name” is the given name of the async task (so yeah,
better name your tasks if you want this to be useful) and “id”
gives the state id responsible for the error. In the case of
errors raised by “throw”, this will refer to the state id immediately
before the throw.</p>
<p>To locate the specified state, look into the compiled source for
a “case <id>:” statement under the task named task_fn_name.
Gathering context this way permits errors to be traced even in 
reorganized code, where source context may or may not be available,
or JS code may not be stored in files at all.</p>
<p>The overhead of this error context accumulation occurs only at 
error propagation time and almost no cost is added to normal
control flow.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>StateMachine.prototype.callback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
    <span class="hljs-keyword">this</span>.state.args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">this</span>.state.err = err;
    <span class="hljs-keyword">this</span>.state.strict_unwind = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (err &amp;&amp; err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) {
        err.cspjsStack = err.cspjsStack || [];
        err.cspjsStack.push((<span class="hljs-keyword">this</span>.task_fn.name || <span class="hljs-string">'unnamed'</span>) + <span class="hljs-string">':'</span> + (<span class="hljs-keyword">this</span>.state.id-<span class="hljs-number">1</span>));
    }
    err &amp;&amp; StateMachine.onerror &amp;&amp; nextTick(StateMachine.onerror, err, <span class="hljs-keyword">this</span>);
    nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
};

StateMachine.prototype.windTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(step)</span> {</span>
    <span class="hljs-keyword">this</span>.state.isUnwinding = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.goTo(step);
};

StateMachine.prototype.unwind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.unwinding.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> where = <span class="hljs-keyword">this</span>.state.unwinding.pop();
        <span class="hljs-keyword">this</span>.state.isUnwinding = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (where.restoreState) {
            <span class="hljs-keyword">this</span>.restoreStateVars(where.restoreState);
            <span class="hljs-keyword">this</span>.unwind();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (where.retry) {
            <span class="hljs-keyword">this</span>.windTo(where.retry);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (where.phi) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.err || <span class="hljs-keyword">this</span>.state.strict_unwind) {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>If we’re strictly unwinding, then regular phi control flow doesn’t apply.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Normal phi jump.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">this</span>.windTo(where.phi);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (where.isError) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.err) {
                <span class="hljs-keyword">this</span>.state.currentErrorStep = where;
                <span class="hljs-keyword">this</span>.goTo(where.step);
            } <span class="hljs-keyword">else</span> {
                nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (where.fn) {
                where.fn();
                nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.beginCleanup(where.state);
                <span class="hljs-keyword">this</span>.goTo(where.step);
            }
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.isFinished) {
        <span class="hljs-keyword">this</span>.state.waiting = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.state.isFinished = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.finalCallback &amp;&amp; <span class="hljs-keyword">this</span>.finalCallback.apply(<span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.state.args);
    }
};

StateMachine.prototype.pushCleanupAction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context, fn, args)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    self.state.unwinding.push({
        cleanup: <span class="hljs-literal">true</span>,
        fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            fn.apply(context, args);
        }
    });
};

StateMachine.prototype.pushCleanupStep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, afterID)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({cleanup: <span class="hljs-literal">true</span>, step: id, state: <span class="hljs-keyword">this</span>.captureStateVars()});
    <span class="hljs-keyword">this</span>.goTo(afterID);
};

StateMachine.prototype.pushErrorStep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, retryID)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({isError: <span class="hljs-literal">true</span>, step: id, retryStep: retryID, unwindPoint: <span class="hljs-keyword">this</span>.state.unwinding.length});
    <span class="hljs-keyword">this</span>.goTo(retryID);
};

StateMachine.prototype.beginCleanup = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(state)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({restoreState: <span class="hljs-keyword">this</span>.captureStateVars()});
    <span class="hljs-keyword">this</span>.restoreStateVars(state);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Retry will place the error handler again on the error stack
and jump to the beginning of the code block that previously
generated the error. Presumably, some corrective actions have
been taken already.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>StateMachine.prototype.retry = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.currentErrorStep) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'SyntaxError: retry statement can only be used within catch blocks'</span>);
    }

    <span class="hljs-keyword">var</span> errorStep = <span class="hljs-keyword">this</span>.state.currentErrorStep;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Finally clauses might need to run between the start of the error handler
and the current retry statement. So we need to unwind through the
finally clauses before stepping out of the catch block. To do this,
insert a plain jump into the unwind sequence at the appropriate
point. And of course, we also restore the error step description
object on the unwind stack so that the surrounding catch block will
attempt to handle any new errors that may occur.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.state.unwinding.splice(errorStep.unwindPoint, <span class="hljs-number">0</span>, errorStep, {retry: errorStep.retryStep});</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Enter a “no error” state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.state.currentErrorStep = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.state.args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">this</span>.state.args.unshift(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">this</span>.state.err = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.state.strict_unwind = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Begin unwinding through the finallies.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.phi();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>A note on semantics. phi used to be a separate stack, which meant
that finally blocks that occur within while loops would all execute
at the end of the while loop only. This is, in general, not desirable
and it is useful to have the finally code executed once for each
scope. For this reason, it is better to have the same unwinding
stack also handle the phi jumps so that error handling code gets
to run as soon as possible.</p>
<p>Currently, if-then-else, while and switch blocks all delimit scopes
for execution of finally handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
StateMachine.prototype.pushPhi = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, captureState)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({phi: id, state: (captureState ? <span class="hljs-keyword">this</span>.captureStateVars() : <span class="hljs-literal">null</span>)});
};

StateMachine.prototype.phi = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JumpTable</span><span class="hljs-params">(id, cases, blockSizes)</span> {</span>
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-keyword">this</span>.cases = cases;
    <span class="hljs-keyword">this</span>.blockSizes = blockSizes;
    <span class="hljs-keyword">this</span>.stepIDs = [];
    <span class="hljs-keyword">this</span>.beyondID = id;

    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, sum = id + <span class="hljs-number">1</span>, ci;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; blockSizes.length; ++i) {
        ci = cases[i];
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ci.length; ++j) {
            <span class="hljs-keyword">this</span>.stepIDs[ci[j]] = sum;
        }
        sum += <span class="hljs-number">1</span> + blockSizes[i]; <span class="hljs-comment">// +1 for the additional "phi"</span>
    }

    <span class="hljs-keyword">this</span>.beyondID = sum;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

JumpTable.prototype.jumpToCase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(sm, caseVal)</span> {</span>
    sm.pushPhi(<span class="hljs-keyword">this</span>.beyondID);
    <span class="hljs-keyword">var</span> stepID = <span class="hljs-keyword">this</span>.stepIDs[caseVal];
    <span class="hljs-keyword">if</span> (!stepID) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unhandled case '"</span> + caseVal + <span class="hljs-string">"' at step "</span> + <span class="hljs-keyword">this</span>.id);
    }
    sm.goTo(stepID);
};

StateMachine.prototype.jumpTable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, cases, blockSizes)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>cases[i] is an array of case values that all map
to the same block whose size is given by blockSizes[i].</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!cases) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.task_fn.cachedJumpTable[id];
    }

    console.assert(cases.length === blockSizes.length);

    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.task_fn.cachedJumpTable[id] = <span class="hljs-keyword">new</span> JumpTable(id, cases, blockSizes));
};

StateMachine.prototype.channel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Channel();
};

StateMachine.prototype.resolve = Channel.resolve;

module.exports = StateMachine;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
